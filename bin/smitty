#!/usr/bin/env ruby
$:.unshift(File.join(File.dirname(__FILE__), '/../lib'))
require 'mail'
require 'docopt'
require 'nokogiri'
require 'premailer'
require 'smitty'

# Parse arguments
begin
  args = Docopt::docopt(Smitty::USAGE, {version: Smitty::VERSION})
rescue Docopt::Exit => e
  puts e.message
  exit(0)
end

# Connect to the smtp server and set Mail default
begin
  # Default server is localhost and port is 25
  smtp_server = args['--server'].nil? ? 'localhost' : args['--server']
  smtp_port = args['--port'].nil? ? 25 : args['--port'].to_i
  smtp_conn = Net::SMTP.new(smtp_server, smtp_port)
  # Enable TLS
  smtp_conn.enable_tls() if args['--ssl']
  # Use authentication exit if username provided but no password
  if args['--username']
    Smitty.croak('No password provided') if args['--password'].nil?
    smtp_conn.start(smtp_server, args['--username'], args['--password'], :plain)
  else
    smtp_conn.start()
  end
  Mail.defaults do
    delivery_method :smtp_connection, { :connection => smtp_conn }
  end
rescue Exception => e
  Smitty.croak("Could not connect to SMTP server #{smtp_server}:#{smtp_port}", e.message)
end

attachments = args['-a'].split(',') if args['-a']
from_address = args['<from_address>']
subject = args['<subject>']

# Read to_file into list of addresses
begin
  to_addresses = File.readlines(args['<to_file>']).map(&:chomp)
rescue Errno::ENOENT => e
  Smitty.croak("Count not open #{args['<to_file>']}", e.message)
end

# Read in template
begin
  template = Premailer.new(args['<template>'])
rescue Errno::ENOENT => e
  Smitty.croak("Could not open #{args['<to_file>']}", e.message)
end

# Possible template variables
# name=file.txt
# name=constant
variables = args['--replace'].split(',').map do |variable|
  pairs = variable.split('=')
  # content is a file 
  begin
    with_content = File.readlines(pairs[1]).map(&:chomp)
    # If to_addresses length does not equal with content length we don't have
    # enough variables for each recipient
    Smitty.croak("#{pairs[0]} content length not equal to recipients") if with_content.length != to_addresses.length
  # else it's a constant value
  rescue Errno::ENOENT => e 
    with_content = pairs[1]
  end
  {replace_string: pairs[0], with: with_content }
end

# Loop over each receipient, create a temporary template,
# replace variables, and send the message
to_addresses.each do |to_address|
  template_copy = String.new(template.to_inline_css)
  subject_copy = String.new(subject)
  # Replace each variable in the template
  variables.each do |variable|
    if variable[:with].kind_of?(Array)
      sub_text = variable[:with].shift()
    else
      sub_text = variable[:with]
    end
    template_copy.gsub!("{{#{variable[:replace_string]}}}", sub_text)
    subject_copy.gsub!("{{#{variable[:replace_string]}}}", sub_text)
  end
  # Create the new mail object
  mail = Mail.new()
  mail.from = from_address
  mail.to = to_address
  mail.bcc = args['--bcc'] unless args['--bcc'].nil?
  mail.subject = subject_copy
  mail.text_part do
    body Nokogiri::HTML(template_copy).text
  end
  mail.html_part do
    content_type 'text/html; charset=UTF-8'
    body template_copy
  end
  # Attach each file to the message
  begin
    attachments.each { |file| mail.add_file(file) } unless attachments.nil?
  rescue Exception => e
    Smitty.croak('Could not attach file', e.message)
  end
  if args['--dry-run']
    puts mail.to_s
  else
    puts "Message delivered to #{to_address}"
    mail.deliver!
  end
end